/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j Spatial.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.spatial.doc.examples;

import static org.neo4j.configuration.GraphDatabaseSettings.DEFAULT_DATABASE_NAME;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.Callable;
import java.util.stream.Stream;
import org.neo4j.configuration.GraphDatabaseSettings;
import org.neo4j.gis.spatial.functions.SpatialFunctions;
import org.neo4j.gis.spatial.procedures.SpatialProcedures;
import org.neo4j.gis.spatial.utilities.SpatialApiBase;
import org.neo4j.internal.kernel.api.procs.DescribedSignature;
import org.neo4j.internal.kernel.api.procs.FieldSignature;
import org.neo4j.internal.kernel.api.procs.ProcedureSignature;
import org.neo4j.internal.kernel.api.procs.UserFunctionSignature;
import org.neo4j.kernel.api.QueryLanguage;
import org.neo4j.kernel.api.procedure.GlobalProcedures;
import org.neo4j.kernel.api.procedure.ProcedureView;
import org.neo4j.kernel.internal.GraphDatabaseAPI;
import org.neo4j.spatial.doc.examples.utils.Mapper;
import org.neo4j.spatial.osm.server.plugin.procedures.OsmSpatialProcedures;
import org.neo4j.test.TestDatabaseManagementServiceBuilder;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

@Command(name = "ApiDocGenerator", mixinStandardHelpOptions = true)
public class ApiDocGenerator implements Callable<Integer> {

	@Option(names = {"-i", "--index-file"}, description = "The file location of the doc index")
	private Path indexFile = Path.of("./docs/docs/modules/ROOT/partials/generated/api/index.adoc");

	@Option(names = {"-n", "--nav-file"}, description = "The file location of the navigation")
	private Path navFile = Path.of("./docs/docs/modules/ROOT/partials/generated/api-nav.adoc");

	@Option(names = {"-p",
			"--partials-root"}, description = "The root directory where the partials for the api doc should be placed in")
	private Path partialsRoot = Path.of("./docs/docs/modules/ROOT/partials/generated/api");

	@Option(names = {"-c",
			"--customizable-root"}, description = "The root directory where the customizable doc file is placed in.")
	private Path customizableRoot = Path.of("./docs/docs/modules/ROOT/pages/api");

	public static final String GENERATED_COMMENT =
			"// This file is generated by " + ApiDocGenerator.class.getName() + ", do not edit it manually\n";

	public static void main(String... args) {
		int exitCode = new CommandLine(new ApiDocGenerator()).execute(args);
		System.exit(exitCode);
	}

	record ApiEntry(DescribedSignature sig, Class<? extends SpatialApiBase> aClass) {

	}

	@Override
	public Integer call() throws Exception {
		Structure root = new Structure(null);
		for (Class<? extends SpatialApiBase> aClass : List.of(SpatialFunctions.class, SpatialProcedures.class,
				OsmSpatialProcedures.class)) {

			try (var neo4j = new TestDatabaseManagementServiceBuilder()
					.setConfig(GraphDatabaseSettings.procedure_unrestricted, List.of("spatial.*"))
					.impermanent()
					.build()) {

				GlobalProcedures procedures = ((GraphDatabaseAPI) neo4j.database(DEFAULT_DATABASE_NAME))
						.getDependencyResolver()
						.resolveDependency(GlobalProcedures.class);
				procedures.registerProcedure(aClass);
				procedures.registerFunction(aClass);

				ProcedureView currentView = procedures.getCurrentView();
				Stream.of(
								currentView.getAllNonAggregatingFunctions(QueryLanguage.CYPHER_5),
								currentView.getAllAggregatingFunctions(QueryLanguage.CYPHER_5),
								currentView.getAllProcedures(QueryLanguage.CYPHER_5)
						)
						.flatMap(stream -> stream)
						.map(sig -> new ApiEntry(sig, aClass))
						.forEach(root::add);
			}
		}
		Structure spatial = root.nested.get("spatial");
		spatial.writeDoc();
		spatial.writeNav();
		spatial.writeSingleDocs();
		System.out.println("API-Doc successfully generated!");
		return 0;
	}

	private class Structure {

		String namespace;
		Map<String, Structure> nested = new TreeMap<>();
		Set<ApiEntry> apiEntries = new TreeSet<>(Comparator.comparing(e -> e.sig.name().name()));

		public Structure(String namespace) {
			this.namespace = namespace;
		}

		public void add(ApiEntry apiEntry) {
			String[] parts = apiEntry.sig.name().namespace();
			Structure current = this;
			StringBuilder currentNS = new StringBuilder();
			for (String part : parts) {
				if (!currentNS.isEmpty()) {
					currentNS.append(".");
				}
				currentNS.append(part);
				current = current.nested.computeIfAbsent(part, namespace1 -> new Structure(currentNS.toString()));
			}
			current.apiEntries.add(apiEntry);
		}

		public void writeDoc() throws IOException {
			Files.createDirectories(indexFile.getParent());
			try (BufferedWriter writer = Files.newBufferedWriter(indexFile)) {
				writer.append(GENERATED_COMMENT);
				writer.append(generateIndex());
			}
		}

		public void writeNav() throws IOException {
			Files.createDirectories(navFile.getParent());
			try (BufferedWriter writer = Files.newBufferedWriter(navFile)) {
				writer.append(GENERATED_COMMENT);
				writer.append(this.generateNav());
			}
		}

		public void writeSingleDocs() throws IOException {
			for (ApiEntry apiEntry : apiEntries) {
				writeSingleDoc(apiEntry);
			}
			for (Structure value : nested.values()) {
				value.writeSingleDocs();
			}
		}

		private void writeSingleDoc(ApiEntry apiEntry) throws IOException {
			var sig = apiEntry.sig;
			String fqname = sig.name().toString();

			Path customizedFile = customizableRoot.resolve(namespace).resolve(fqname + ".adoc");
			if (!Files.exists(customizedFile)) {
				Files.createDirectories(customizedFile.getParent());
				String commented =
						Files.exists(partialsRoot.resolve(namespace).resolve(fqname + "-examples.adoc")) ? "" : "// ";
				Files.writeString(customizedFile,
						"include::partial$generated/api/" + namespace + "/" + fqname + ".adoc[]\n\n"
								+ commented + "== Examples\n"
								+ commented + "\n"
								+ commented + "include::partial$generated/api/" + namespace + "/" + fqname
								+ "-examples.adoc[]\n");
			}

			Path file = partialsRoot.resolve(namespace).resolve(fqname + ".adoc");
			Files.createDirectories(file.getParent());

			List<FieldSignature> inputs;
			List<FieldSignature> outputs = null;
			boolean deprecated;
			Optional<String> deprecatedBy;
			Optional<String> warning = Optional.empty();
			String type;
			if (sig instanceof ProcedureSignature proc) {
				inputs = proc.inputSignature();
				outputs = proc.outputSignature();
				deprecated = proc.isDeprecated();
				deprecatedBy = proc.deprecated();
				warning = proc.warning();
				type = "procedure";
			} else if (sig instanceof UserFunctionSignature fun) {
				inputs = fun.inputSignature();
				deprecated = fun.isDeprecated();
				deprecatedBy = fun.deprecated();
				type = "function";
			} else {
				throw new IllegalArgumentException("Unknown signature type: " + sig);
			}

			try (BufferedWriter writer = Files.newBufferedWriter(file)) {
				writer.append(GENERATED_COMMENT);
				writer.append("= ").append(fqname).append("\n\n");
				writer.append(":description: This section contains reference documentation for the ")
						.append(fqname).append(" ").append(type)
						.append(".\n\nlabel:").append(type).append("[]");
				if (OsmSpatialProcedures.class.isAssignableFrom(apiEntry.aClass)) {
					writer.append(" label:OSM[]");
				}
				if (deprecated) {
					writer.append(" label:deprecated[]");
				}
				writer.append("\n\n");

				if (sig.description().isPresent()) {
					writer.append("[.emphasis]\n");
					writer.append(sig.description().get()).append("\n\n");
				}

				if (warning.isPresent() || deprecatedBy.isPresent()) {
					String text = warning.orElse("");
					if (deprecatedBy.isPresent() && !deprecatedBy.get().equals(text)) {
						text += "\nThis " + type + " is deprecated by: " + deprecatedBy.get();
					}
					writer.append("[WARNING]\n====\n").append(text).append("\n====\n\n");
				}

				writer.append("== Signature\n\n[source]\n----\n")
						.append(String.valueOf(sig))
						.append("\n----\n\n");

				if (inputs != null && !inputs.isEmpty()) {
					writer.append("== Input parameters\n\n");
					writer.append("[.procedures,opts=header,cols='1,1,1,7']\n");
					writer.append("|===\n");
					writer.append("|Name|Type|Default|Description\n");
					for (FieldSignature input : inputs) {
						writer.append("|").append(input.name())
								.append("|").append(input.neo4jType().toString())
								.append("|").append(input.defaultValue()
										.map(v -> {
											try {
												return Mapper.MAPPER.writeValueAsString(v.javaValue());
											} catch (JsonProcessingException e) {
												throw new RuntimeException(e);
											}
										})
										.orElse("null"))
								.append("\na|").append(Optional.ofNullable(input.getDescription()).orElse(""))
								.append("\n");
					}
					writer.append("|===\n\n");
				}

				if (outputs != null && !outputs.isEmpty()) {
					writer.append("== Output parameters\n\n");
					writer.append("[.procedures,opts=header,cols='1,1,8']\n");
					writer.append("|===\n");
					writer.append("|Name|Type|Description\n");
					for (FieldSignature output : outputs) {
						writer.append("|").append(output.name())
								.append("|").append(output.neo4jType().toString())
								.append("|").append(Optional.ofNullable(output.getDescription()).orElse(""))
								.append("\n");
					}
					writer.append("|===\n\n");
				}
			}
		}

		private String generateIndex() {
			StringBuilder builder = new StringBuilder();
			if (!apiEntries.isEmpty()) {
				builder.append("== ").append(namespace).append("\n\n");
				builder.append("[.procedures,opts=header,cols='5a,1a']\n");
				builder.append("|===\n");
				builder.append("|Qualified Name |Type\n");
				apiEntries.forEach(apiEntry -> {
					var sig = apiEntry.sig;

					boolean deprecated = false;
					String type = "unknown";
					if (sig instanceof ProcedureSignature proc) {
						type = "procedure";
						deprecated = proc.isDeprecated();
					} else if (sig instanceof UserFunctionSignature fun) {
						type = "function";
						deprecated = fun.isDeprecated();
					}

					builder.append("|xref:api/")
							.append(namespace).append("/").append(sig.name()).append(".adoc[")
							.append(sig.name()).append(" icon:book[]]");
					if (OsmSpatialProcedures.class.isAssignableFrom(apiEntry.aClass)) {
						builder.append(" label:OSM[]");
					}
					if (deprecated) {
						builder.append(" label:deprecated[]");
					}
					builder.append("\n");

					if (sig.description().isPresent()) {
						builder.append("\n").append(sig.description().get()).append("\n");
					}
					builder.append("|label:").append(type).append("[]\n");
				});
				builder.append("|===\n\n");
			}

			for (Structure value : nested.values()) {
				builder.append(value.generateIndex());
			}

			return builder.toString();
		}

		private String generateNav() {
			StringBuilder builder = new StringBuilder();
			apiEntries.forEach(apiEntry -> builder
					.append("** xref:api/")
					.append(namespace).append("/")
					.append(apiEntry.sig.name())
					.append(".adoc[]\n"));
			for (Structure value : nested.values()) {
				builder.append(value.generateNav());
			}
			return builder.toString();
		}
	}

}
