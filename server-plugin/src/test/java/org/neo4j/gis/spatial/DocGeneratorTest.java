/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j Spatial.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.gis.spatial;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Stream;
import org.junit.jupiter.api.Test;
import org.neo4j.doc.domain.examples.Mapper;
import org.neo4j.exceptions.KernelException;
import org.neo4j.gis.spatial.functions.SpatialFunctions;
import org.neo4j.gis.spatial.procedures.SpatialProcedures;
import org.neo4j.internal.kernel.api.procs.DescribedSignature;
import org.neo4j.internal.kernel.api.procs.FieldSignature;
import org.neo4j.internal.kernel.api.procs.ProcedureSignature;
import org.neo4j.internal.kernel.api.procs.UserFunctionSignature;
import org.neo4j.kernel.api.QueryLanguage;
import org.neo4j.kernel.api.procedure.GlobalProcedures;
import org.neo4j.kernel.api.procedure.ProcedureView;
import org.neo4j.kernel.internal.GraphDatabaseAPI;

public class DocGeneratorTest extends AbstractApiTest {

	public static final String GENERATED_COMMENT = "// This file is generated by DocGeneratorTest, do not edit it manually\n";

	@Override
	protected void registerApiProceduresAndFunctions() throws KernelException {
		registerProceduresAndFunctions(SpatialFunctions.class);
		registerProceduresAndFunctions(SpatialProcedures.class);
	}

	@Test
	public void generateDocStub() throws IOException {

		GlobalProcedures procedures = ((GraphDatabaseAPI) db).getDependencyResolver()
				.resolveDependency(GlobalProcedures.class);
		ProcedureView currentView = procedures.getCurrentView();

		Structure root = new Structure(null);

		Stream.of(
						currentView.getAllNonAggregatingFunctions(QueryLanguage.CYPHER_5),
						currentView.getAllAggregatingFunctions(QueryLanguage.CYPHER_5),
						currentView.getAllProcedures(QueryLanguage.CYPHER_5)
				)
				.flatMap(stream -> stream)
				.forEach(root::add);

		Structure spatial = root.nested.get("spatial");
		spatial.writeDoc();
		spatial.writeNav();
		spatial.writeSingleDocs();
	}

	private static class Structure {

		String namespace;
		Map<String, Structure> nested = new TreeMap<>();
		Set<DescribedSignature> entries = new TreeSet<>(Comparator.comparing(s -> s.name().name()));

		public Structure(String namespace) {
			this.namespace = namespace;
		}

		public void add(DescribedSignature sig) {
			String[] parts = sig.name().namespace();
			Structure current = this;
			StringBuilder currentNS = new StringBuilder();
			for (String part : parts) {
				if (!currentNS.isEmpty()) {
					currentNS.append(".");
				}
				currentNS.append(part);
				current = current.nested.computeIfAbsent(part, namespace1 -> new Structure(currentNS.toString()));
			}
			current.entries.add(sig);
		}

		public void writeDoc() throws IOException {
			Path file = Path.of("../docs/docs/modules/ROOT/partials/generated/api/index.adoc");
			Files.createDirectories(file.getParent());
			try (BufferedWriter writer = Files.newBufferedWriter(file)) {
				writer.append(GENERATED_COMMENT);
				writer.append(generateIndex());
			}
		}

		public void writeNav() throws IOException {
			Path file = Path.of("../docs/docs/modules/ROOT/partials/generated/api-nav.adoc");
			Files.createDirectories(file.getParent());
			try (BufferedWriter writer = Files.newBufferedWriter(file)) {
				writer.append(GENERATED_COMMENT);
				writer.append(this.generateNav());
			}
		}

		public void writeSingleDocs() throws IOException {
			for (DescribedSignature entry : entries) {
				writeSingleDoc(entry);
			}
			for (Structure value : nested.values()) {
				value.writeSingleDocs();
			}
		}

		private void writeSingleDoc(DescribedSignature entry) throws IOException {
			String fqname = entry.name().toString();

			Path customizedFile = Path.of("../docs/docs/modules/ROOT/pages/api", namespace, fqname + ".adoc");
			if (!Files.exists(customizedFile)) {
				Files.createDirectories(customizedFile.getParent());
				String commented = Files.exists(
						Path.of("../docs/docs/modules/ROOT/partials/generated/api", namespace, fqname + "-examples.adoc"))
						? "" : "// ";
				Files.writeString(customizedFile,
						"include::partial$generated/api/" + namespace + "/" + fqname + ".adoc[]\n\n"
								+ commented + "== Examples\n"
								+ commented + "\n"
								+ commented + "include::partial$generated/api/" + namespace + "/" + fqname
								+ "-examples.adoc[]\n");
			}

			Path file = Path.of("../docs/docs/modules/ROOT/partials/generated/api", namespace, fqname + ".adoc");
			Files.createDirectories(file.getParent());

			List<FieldSignature> inputs;
			List<FieldSignature> outputs = null;
			boolean deprecated;
			Optional<String> deprecatedBy;
			Optional<String> warning = Optional.empty();
			String type;
			if (entry instanceof ProcedureSignature proc) {
				inputs = proc.inputSignature();
				outputs = proc.outputSignature();
				deprecated = proc.isDeprecated();
				deprecatedBy = proc.deprecated();
				warning = proc.warning();
				type = "procedure";
			} else if (entry instanceof UserFunctionSignature fun) {
				inputs = fun.inputSignature();
				deprecated = fun.isDeprecated();
				deprecatedBy = fun.deprecated();
				type = "function";
			} else {
				throw new IllegalArgumentException("Unknown signature type: " + entry);
			}

			try (BufferedWriter writer = Files.newBufferedWriter(file)) {
				writer.append(GENERATED_COMMENT);
				writer.append("= ").append(fqname).append("\n\n");
				writer.append(":description: This section contains reference documentation for the ")
						.append(fqname).append(" ").append(type)
						.append(".\n\nlabel:").append(type).append("[]");

				if (deprecated) {
					writer.append(" label:deprecated[]");
				}
				writer.append("\n\n");

				if (entry.description().isPresent()) {
					writer.append("[.emphasis]\n");
					writer.append(entry.description().get()).append("\n\n");
				}

				if (warning.isPresent() || deprecatedBy.isPresent()) {
					String text = warning.orElse("");
					if (deprecatedBy.isPresent() && !deprecatedBy.get().equals(text)) {
						text += "\nThis " + type + " is deprecated by: " + deprecatedBy.get();
					}
					writer.append("[WARNING]\n====\n").append(text).append("\n====\n\n");
				}

				writer.append("== Signature\n\n[source]\n----\n")
						.append(String.valueOf(entry))
						.append("\n----\n\n");

				if (inputs != null && !inputs.isEmpty()) {
					writer.append("== Input parameters\n\n");
					writer.append("[.procedures,opts=header,cols='1,1,1,7']\n");
					writer.append("|===\n");
					writer.append("|Name|Type|Default|Description\n");
					for (FieldSignature input : inputs) {
						writer.append("|").append(input.name())
								.append("|").append(input.neo4jType().toString())
								.append("|").append(input.defaultValue()
										.map(v -> {
											try {
												return Mapper.MAPPER.writeValueAsString(v.javaValue());
											} catch (JsonProcessingException e) {
												throw new RuntimeException(e);
											}
										})
										.orElse("null"))
								.append("\na|").append(Optional.ofNullable(input.getDescription()).orElse(""))
								.append("\n");
					}
					writer.append("|===\n\n");
				}

				if (outputs != null && !outputs.isEmpty()) {
					writer.append("== Output parameters\n\n");
					writer.append("[.procedures,opts=header,cols='1,1,8']\n");
					writer.append("|===\n");
					writer.append("|Name|Type|Description\n");
					for (FieldSignature output : outputs) {
						writer.append("|").append(output.name())
								.append("|").append(output.neo4jType().toString())
								.append("|").append(Optional.ofNullable(output.getDescription()).orElse(""))
								.append("\n");
					}
					writer.append("|===\n\n");
				}
			}
		}

		private String generateIndex() {
			StringBuilder builder = new StringBuilder();
			if (!entries.isEmpty()) {
				builder.append("== ").append(namespace).append("\n\n");
				builder.append("[.procedures,opts=header,cols='5a,1a']\n");
				builder.append("|===\n");
				builder.append("|Qualified Name |Type\n");
				entries.forEach(sig -> {

					boolean deprecated = false;
					String type = "unknown";
					if (sig instanceof ProcedureSignature proc) {
						type = "procedure";
						deprecated = proc.isDeprecated();
					} else if (sig instanceof UserFunctionSignature fun) {
						type = "function";
						deprecated = fun.isDeprecated();
					}

					builder.append("|xref:api/")
							.append(namespace).append("/").append(sig.name()).append(".adoc[")
							.append(sig.name()).append(" icon:book[]]");
					if (deprecated) {
						builder.append(" label:deprecated[]");
					}
					builder.append("\n");

					if (sig.description().isPresent()) {
						builder.append("\n").append(sig.description().get()).append("\n");
					}
					builder.append("|label:").append(type).append("[]\n");
				});
				builder.append("|===\n\n");
			}

			for (Structure value : nested.values()) {
				builder.append(value.generateIndex());
			}

			return builder.toString();
		}

		private String generateNav() {
			StringBuilder builder = new StringBuilder();
			entries.forEach(sig -> {
				builder
						.append("** xref:api/")
						.append(namespace).append("/")
						.append(sig.name())
						.append(".adoc[]\n");
			});
			for (Structure value : nested.values()) {
				builder.append(value.generateNav());
			}
			return builder.toString();
		}
	}

}
